Sources\main.o:     file format elf32-littlearmSources\main.oarchitecture: arm, flags 0x00000011:HAS_RELOC, HAS_SYMSstart address 0x00000000private flags = 5000000: [Version5 EABI]Sections:Idx Name          Size      VMA       LMA       File off  Algn  0 .text         00000000  00000000  00000000  00000034  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE  1 .data         00000000  00000000  00000000  00000034  2**0                  CONTENTS, ALLOC, LOAD, DATA  2 .bss          00000000  00000000  00000000  00000034  2**0                  ALLOC  3 .bss.km       00000004  00000000  00000000  00000034  2**2                  ALLOC  4 .data.cmpmens3 00000008  00000000  00000000  00000034  2**2                  CONTENTS, ALLOC, LOAD, DATA  5 .data.cmpmens4 00000004  00000000  00000000  0000003c  2**2                  CONTENTS, ALLOC, LOAD, DATA  6 .data.cmpmens1 00000008  00000000  00000000  00000040  2**2                  CONTENTS, ALLOC, LOAD, DATA  7 .data.mens    000002bc  00000000  00000000  00000048  2**2                  CONTENTS, ALLOC, LOAD, DATA  8 .data.mensStatus 0000008c  00000000  00000000  00000304  2**2                  CONTENTS, ALLOC, LOAD, DATA  9 .data.close   00000050  00000000  00000000  00000390  2**2                  CONTENTS, ALLOC, LOAD, DATA 10 .data.cmpmens 00000034  00000000  00000000  000003e0  2**2                  CONTENTS, ALLOC, LOAD, DATA 11 .data.automatico 00000001  00000000  00000000  00000414  2**0                  CONTENTS, ALLOC, LOAD, DATA 12 .text.vUART_init 0000018c  00000000  00000000  00000418  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 13 .text.vADC_LPTMR_init 0000008c  00000000  00000000  000005a4  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 14 .text.vUART_send 00000034  00000000  00000000  00000630  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 15 .text.vUART_echo 00000034  00000000  00000000  00000664  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 16 .text.u8UART_receive 00000040  00000000  00000000  00000698  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 17 .text.vUART_receive_buffer 0000004c  00000000  00000000  000006d8  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 18 .text.vUART_send_msg 00000038  00000000  00000000  00000724  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 19 .text.u8parser 00000100  00000000  00000000  0000075c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 20 .text.vUART_connect 000000e0  00000000  00000000  0000085c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 21 .text.vUART_update_process 0000023c  00000000  00000000  0000093c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 22 .text.main    00000094  00000000  00000000  00000b78  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 23 .text.LPTimer_IRQHandler 00000030  00000000  00000000  00000c0c  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 24 .text.ADC1_IRQHandler 000002a8  00000000  00000000  00000c3c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 25 .debug_info   00000d28  00000000  00000000  00000ee4  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 26 .debug_abbrev 000001b2  00000000  00000000  00001c0c  2**0                  CONTENTS, READONLY, DEBUGGING 27 .debug_loc    00000290  00000000  00000000  00001dbe  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 28 .debug_aranges 00000080  00000000  00000000  0000204e  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 29 .debug_macinfo 00061cad  00000000  00000000  000020ce  2**0                  CONTENTS, READONLY, DEBUGGING 30 .debug_line   00000374  00000000  00000000  00063d7b  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 31 .debug_str    00000541  00000000  00000000  000640ef  2**0                  CONTENTS, READONLY, DEBUGGING 32 .comment      0000007a  00000000  00000000  00064630  2**0                  CONTENTS, READONLY 33 .ARM.attributes 0000003b  00000000  00000000  000646aa  2**0                  CONTENTS, READONLY 34 .debug_frame  0000017c  00000000  00000000  000646e8  2**2                  CONTENTS, RELOC, READONLY, DEBUGGINGSYMBOL TABLE:00000000 l    df *ABS*	00000000 main.c00000000 l    d  .text	00000000 .text00000000 l    d  .data	00000000 .data00000000 l    d  .bss	00000000 .bss00000000 l    d  .bss.km	00000000 .bss.km00000000 l    d  .data.cmpmens3	00000000 .data.cmpmens300000000 l    d  .data.cmpmens4	00000000 .data.cmpmens400000000 l    d  .data.cmpmens1	00000000 .data.cmpmens100000000 l    d  .data.mens	00000000 .data.mens00000000 l    d  .data.mensStatus	00000000 .data.mensStatus00000000 l    d  .data.close	00000000 .data.close00000000 l    d  .data.cmpmens	00000000 .data.cmpmens00000000 l    d  .data.automatico	00000000 .data.automatico00000000 l    d  .text.vUART_init	00000000 .text.vUART_init00000000 l    d  .text.vADC_LPTMR_init	00000000 .text.vADC_LPTMR_init00000000 l    d  .text.vUART_send	00000000 .text.vUART_send00000000 l    d  .text.vUART_echo	00000000 .text.vUART_echo00000000 l    d  .text.u8UART_receive	00000000 .text.u8UART_receive00000000 l    d  .text.vUART_receive_buffer	00000000 .text.vUART_receive_buffer00000000 l    d  .text.vUART_send_msg	00000000 .text.vUART_send_msg00000000 l    d  .text.u8parser	00000000 .text.u8parser00000000 l    d  .text.vUART_connect	00000000 .text.vUART_connect00000000 l    d  .text.vUART_update_process	00000000 .text.vUART_update_process00000000 l    d  .text.main	00000000 .text.main00000000 l    d  .text.LPTimer_IRQHandler	00000000 .text.LPTimer_IRQHandler00000000 l    d  .text.ADC1_IRQHandler	00000000 .text.ADC1_IRQHandler00000000 l    d  .debug_info	00000000 .debug_info00000000 l    d  .debug_abbrev	00000000 .debug_abbrev00000000 l    d  .debug_loc	00000000 .debug_loc00000000 l    d  .debug_aranges	00000000 .debug_aranges00000000 l    d  .debug_macinfo	00000000 .debug_macinfo00000000 l    d  .debug_line	00000000 .debug_line00000000 l    d  .debug_str	00000000 .debug_str00000000 l    d  .debug_frame	00000000 .debug_frame00000000 l    d  .comment	00000000 .comment00000000 l    d  .ARM.attributes	00000000 .ARM.attributes00000001       O *COM*	00000001 status_act00000001       O *COM*	00000001 status_prev00000004       O *COM*	00000004 adc_value00000014       O *COM*	00000004 captura00000000 g     O .bss.km	00000004 km00000004       O *COM*	00000004 cont00000000 g     O .data.cmpmens3	00000008 cmpmens300000000 g     O .data.cmpmens4	00000002 cmpmens400000000 g     O .data.cmpmens1	00000005 cmpmens100000000 g     O .data.mens	000002bc mens00000000 g     O .data.mensStatus	0000008c mensStatus00000000 g     O .data.close	00000050 close00000000 g     O .data.cmpmens	00000032 cmpmens0000012c       O *COM*	00000004 buffer00000001       O *COM*	00000001 LED00000000 g     O .data.automatico	00000001 automatico00000001       O *COM*	00000001 isOn00000000 g     F .text.vUART_init	0000018c vUART_init00000000 g     F .text.vADC_LPTMR_init	0000008a vADC_LPTMR_init00000000 g     F .text.vUART_send	00000034 vUART_send00000000 g     F .text.vUART_echo	00000034 vUART_echo00000000 g     F .text.u8UART_receive	00000040 u8UART_receive00000000 g     F .text.vUART_receive_buffer	0000004a vUART_receive_buffer00000000 g     F .text.vUART_send_msg	00000038 vUART_send_msg00000000 g     F .text.u8parser	000000fe u8parser00000000 g     F .text.vUART_connect	000000e0 vUART_connect00000000 g     F .text.vUART_update_process	0000023c vUART_update_process00000000 g     F .text.main	00000094 main00000000 g     F .text.LPTimer_IRQHandler	00000030 LPTimer_IRQHandler00000000 g     F .text.ADC1_IRQHandler	000002a6 ADC1_IRQHandlerDisassembly of section .text.vUART_init:00000000 <vUART_init>:unsigned char buffer[300];unsigned char LED;unsigned char automatico = '1';unsigned char isOn;void vUART_init(void) {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0	SIM_SCGC4 = 0x00000C00; 	//Hab clk UART0 y UART1   4:	f44f 43e0 	mov.w	r3, #28672	; 0x7000   8:	f2c4 0304 	movt	r3, #16388	; 0x4004   c:	f503 5381 	add.w	r3, r3, #4128	; 0x1020  10:	f103 0314 	add.w	r3, r3, #20  14:	f44f 6240 	mov.w	r2, #3072	; 0xc00  18:	601a      	str	r2, [r3, #0]	UART0_BDH = 0;  1a:	f44f 4320 	mov.w	r3, #40960	; 0xa000  1e:	f2c4 0306 	movt	r3, #16390	; 0x4006  22:	f04f 0200 	mov.w	r2, #0  26:	701a      	strb	r2, [r3, #0]	UART0_BDL = 11;   		//115200 bps  28:	f44f 4320 	mov.w	r3, #40960	; 0xa000  2c:	f2c4 0306 	movt	r3, #16390	; 0x4006  30:	f04f 020b 	mov.w	r2, #11  34:	705a      	strb	r2, [r3, #1]	UART1_BDH = 0;  36:	f44f 4330 	mov.w	r3, #45056	; 0xb000  3a:	f2c4 0306 	movt	r3, #16390	; 0x4006  3e:	f04f 0200 	mov.w	r2, #0  42:	701a      	strb	r2, [r3, #0]	UART1_BDL = 11;    		//115200 bps  44:	f44f 4330 	mov.w	r3, #45056	; 0xb000  48:	f2c4 0306 	movt	r3, #16390	; 0x4006  4c:	f04f 020b 	mov.w	r2, #11  50:	705a      	strb	r2, [r3, #1]	UART0_C2 = 12; 			// bit 3: Hab Tx, bit 2: Hab Rx  52:	f44f 4320 	mov.w	r3, #40960	; 0xa000  56:	f2c4 0306 	movt	r3, #16390	; 0x4006  5a:	f04f 020c 	mov.w	r2, #12  5e:	70da      	strb	r2, [r3, #3]	UART1_C2 = 12;  60:	f44f 4330 	mov.w	r3, #45056	; 0xb000  64:	f2c4 0306 	movt	r3, #16390	; 0x4006  68:	f04f 020c 	mov.w	r2, #12  6c:	70da      	strb	r2, [r3, #3]	//Pines	SIM_SCGC5 = 0x00000C00; 	//Hab clk PORTB (PB16 y 17 son Rx y Tx) y PORTC  6e:	f44f 43e0 	mov.w	r3, #28672	; 0x7000  72:	f2c4 0304 	movt	r3, #16388	; 0x4004  76:	f503 5381 	add.w	r3, r3, #4128	; 0x1020  7a:	f103 0318 	add.w	r3, r3, #24  7e:	f44f 6240 	mov.w	r2, #3072	; 0xc00  82:	601a      	str	r2, [r3, #0]	PORTB_PCR16 =0x00000300; //Hab clk PB16 Rx  84:	f44f 4320 	mov.w	r3, #40960	; 0xa000  88:	f2c4 0304 	movt	r3, #16388	; 0x4004  8c:	f44f 7240 	mov.w	r2, #768	; 0x300  90:	641a      	str	r2, [r3, #64]	; 0x40	PORTB_PCR17 =0x00000300; //Hab clk PB17 Tx  92:	f44f 4320 	mov.w	r3, #40960	; 0xa000  96:	f2c4 0304 	movt	r3, #16388	; 0x4004  9a:	f44f 7240 	mov.w	r2, #768	; 0x300  9e:	645a      	str	r2, [r3, #68]	; 0x44	PORTC_PCR3 =0x00000300; 	//Hab clk PC3 Rx  a0:	f44f 4330 	mov.w	r3, #45056	; 0xb000  a4:	f2c4 0304 	movt	r3, #16388	; 0x4004  a8:	f44f 7240 	mov.w	r2, #768	; 0x300  ac:	60da      	str	r2, [r3, #12]	PORTC_PCR4 =0x00000300; 	//Hab clk PC4 Tx  ae:	f44f 4330 	mov.w	r3, #45056	; 0xb000  b2:	f2c4 0304 	movt	r3, #16388	; 0x4004  b6:	f44f 7240 	mov.w	r2, #768	; 0x300  ba:	611a      	str	r2, [r3, #16]	// LED	SIM_SCGC5 |= 0x00002400;			//HABILITAR RELOJ  bc:	f44f 43e0 	mov.w	r3, #28672	; 0x7000  c0:	f2c4 0304 	movt	r3, #16388	; 0x4004  c4:	f44f 42e0 	mov.w	r2, #28672	; 0x7000  c8:	f2c4 0204 	movt	r2, #16388	; 0x4004  cc:	f502 5281 	add.w	r2, r2, #4128	; 0x1020  d0:	f102 0218 	add.w	r2, r2, #24  d4:	6812      	ldr	r2, [r2, #0]  d6:	f442 5210 	orr.w	r2, r2, #9216	; 0x2400  da:	f503 5381 	add.w	r3, r3, #4128	; 0x1020  de:	f103 0318 	add.w	r3, r3, #24  e2:	601a      	str	r2, [r3, #0]	PORTB_PCR21 =0X00000100;		//Seleccionar pin como GPIO  e4:	f44f 4320 	mov.w	r3, #40960	; 0xa000  e8:	f2c4 0304 	movt	r3, #16388	; 0x4004  ec:	f44f 7280 	mov.w	r2, #256	; 0x100  f0:	655a      	str	r2, [r3, #84]	; 0x54	PORTB_PCR22 =0X00000100;		//Seleccionar pin como GPIO  f2:	f44f 4320 	mov.w	r3, #40960	; 0xa000  f6:	f2c4 0304 	movt	r3, #16388	; 0x4004  fa:	f44f 7280 	mov.w	r2, #256	; 0x100  fe:	659a      	str	r2, [r3, #88]	; 0x58	PORTE_PCR26 =0X00000100;		//Seleccionar pin como GPIO 100:	f44f 4350 	mov.w	r3, #53248	; 0xd000 104:	f2c4 0304 	movt	r3, #16388	; 0x4004 108:	f44f 7280 	mov.w	r2, #256	; 0x100 10c:	669a      	str	r2, [r3, #104]	; 0x68	GPIOB_PDDR |= (1 << 21); 10e:	f24f 0340 	movw	r3, #61504	; 0xf040 112:	f2c4 030f 	movt	r3, #16399	; 0x400f 116:	f24f 0240 	movw	r2, #61504	; 0xf040 11a:	f2c4 020f 	movt	r2, #16399	; 0x400f 11e:	6952      	ldr	r2, [r2, #20] 120:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000 124:	615a      	str	r2, [r3, #20]	PORTC_PCR2 =(1<<8); 126:	f44f 4330 	mov.w	r3, #45056	; 0xb000 12a:	f2c4 0304 	movt	r3, #16388	; 0x4004 12e:	f44f 7280 	mov.w	r2, #256	; 0x100 132:	609a      	str	r2, [r3, #8]	GPIOC_PDDR = (1 << 2); 134:	f24f 0380 	movw	r3, #61568	; 0xf080 138:	f2c4 030f 	movt	r3, #16399	; 0x400f 13c:	f04f 0204 	mov.w	r2, #4 140:	615a      	str	r2, [r3, #20]	SIM_SCGC3 |= (1 << 27);  //Clock ADC1 142:	f44f 43e0 	mov.w	r3, #28672	; 0x7000 146:	f2c4 0304 	movt	r3, #16388	; 0x4004 14a:	f44f 42e0 	mov.w	r2, #28672	; 0x7000 14e:	f2c4 0204 	movt	r2, #16388	; 0x4004 152:	f502 5281 	add.w	r2, r2, #4128	; 0x1020 156:	f102 0210 	add.w	r2, r2, #16 15a:	6812      	ldr	r2, [r2, #0] 15c:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000 160:	f503 5381 	add.w	r3, r3, #4128	; 0x1020 164:	f103 0310 	add.w	r3, r3, #16 168:	601a      	str	r2, [r3, #0]	ADC1_CFG1 = 0xC;   //Conv 16 bits 16a:	f44f 4330 	mov.w	r3, #45056	; 0xb000 16e:	f2c4 030b 	movt	r3, #16395	; 0x400b 172:	f04f 020c 	mov.w	r2, #12 176:	609a      	str	r2, [r3, #8]	ADC1_SC1A =18; 178:	f44f 4330 	mov.w	r3, #45056	; 0xb000 17c:	f2c4 030b 	movt	r3, #16395	; 0x400b 180:	f04f 0212 	mov.w	r2, #18 184:	601a      	str	r2, [r3, #0]} 186:	46bd      	mov	sp, r7 188:	bc80      	pop	{r7} 18a:	4770      	bx	lrDisassembly of section .text.vADC_LPTMR_init:00000000 <vADC_LPTMR_init>:void vADC_LPTMR_init(void) {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0	SIM_SCGC5 = (1 << 11) + (1 << 10) + 1; //reloj PORTC y LPTMR0   4:	f44f 43e0 	mov.w	r3, #28672	; 0x7000   8:	f2c4 0304 	movt	r3, #16388	; 0x4004   c:	f503 5381 	add.w	r3, r3, #4128	; 0x1020  10:	f103 0318 	add.w	r3, r3, #24  14:	f640 4201 	movw	r2, #3073	; 0xc01  18:	601a      	str	r2, [r3, #0]	LPTMR0_PSR = 5; //PREESCALER  1a:	f04f 0300 	mov.w	r3, #0  1e:	f2c4 0304 	movt	r3, #16388	; 0x4004  22:	f04f 0205 	mov.w	r2, #5  26:	605a      	str	r2, [r3, #4]	LPTMR0_CSR = (1 << 6) + 1; //LPTMR, interrupcion   28:	f04f 0300 	mov.w	r3, #0  2c:	f2c4 0304 	movt	r3, #16388	; 0x4004  30:	f04f 0241 	mov.w	r2, #65	; 0x41  34:	601a      	str	r2, [r3, #0]	LPTMR0_CMR = 30000; //5 seg  36:	f04f 0300 	mov.w	r3, #0  3a:	f2c4 0304 	movt	r3, #16388	; 0x4004  3e:	f247 5230 	movw	r2, #30000	; 0x7530  42:	609a      	str	r2, [r3, #8]	NVICICER1 =(1<<58%32); //  44:	f44f 4361 	mov.w	r3, #57600	; 0xe100  48:	f2ce 0300 	movt	r3, #57344	; 0xe000  4c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000  50:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84	NVICISER1 |=(1<<58%32); //	  54:	f44f 4361 	mov.w	r3, #57600	; 0xe100  58:	f2ce 0300 	movt	r3, #57344	; 0xe000  5c:	f44f 4261 	mov.w	r2, #57600	; 0xe100  60:	f2ce 0200 	movt	r2, #57344	; 0xe000  64:	6852      	ldr	r2, [r2, #4]  66:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000  6a:	605a      	str	r2, [r3, #4]	NVICISER2 |=(1<<(73%32));	//adc1  6c:	f44f 4361 	mov.w	r3, #57600	; 0xe100  70:	f2ce 0300 	movt	r3, #57344	; 0xe000  74:	f44f 4261 	mov.w	r2, #57600	; 0xe100  78:	f2ce 0200 	movt	r2, #57344	; 0xe000  7c:	6892      	ldr	r2, [r2, #8]  7e:	f442 7200 	orr.w	r2, r2, #512	; 0x200  82:	609a      	str	r2, [r3, #8]}  84:	46bd      	mov	sp, r7  86:	bc80      	pop	{r7}  88:	4770      	bx	lr  8a:	bf00      	nopDisassembly of section .text.vUART_send:00000000 <vUART_send>:void vUART_send(unsigned char dato)				// Metodo para enviar datos{   0:	b480      	push	{r7}   2:	b083      	sub	sp, #12   4:	af00      	add	r7, sp, #0   6:	4603      	mov	r3, r0   8:	71fb      	strb	r3, [r7, #7]	do {	} while (!(UART1_S1 & UART_S1_TDRE_MASK));   a:	f44f 4330 	mov.w	r3, #45056	; 0xb000   e:	f2c4 0306 	movt	r3, #16390	; 0x4006  12:	791b      	ldrb	r3, [r3, #4]  14:	b2db      	uxtb	r3, r3  16:	b2db      	uxtb	r3, r3  18:	b25b      	sxtb	r3, r3  1a:	2b00      	cmp	r3, #0  1c:	daf5      	bge.n	a <vUART_send+0xa>	UART1_D = dato;  1e:	f44f 4330 	mov.w	r3, #45056	; 0xb000  22:	f2c4 0306 	movt	r3, #16390	; 0x4006  26:	79fa      	ldrb	r2, [r7, #7]  28:	71da      	strb	r2, [r3, #7]}  2a:	f107 070c 	add.w	r7, r7, #12  2e:	46bd      	mov	sp, r7  30:	bc80      	pop	{r7}  32:	4770      	bx	lrDisassembly of section .text.vUART_echo:00000000 <vUART_echo>:void vUART_echo(unsigned char dato)				// Metodo para enviar datos{   0:	b480      	push	{r7}   2:	b083      	sub	sp, #12   4:	af00      	add	r7, sp, #0   6:	4603      	mov	r3, r0   8:	71fb      	strb	r3, [r7, #7]	do {	} while (!(UART1_S1 & UART_S1_TDRE_MASK));   a:	f44f 4330 	mov.w	r3, #45056	; 0xb000   e:	f2c4 0306 	movt	r3, #16390	; 0x4006  12:	791b      	ldrb	r3, [r3, #4]  14:	b2db      	uxtb	r3, r3  16:	b2db      	uxtb	r3, r3  18:	b25b      	sxtb	r3, r3  1a:	2b00      	cmp	r3, #0  1c:	daf5      	bge.n	a <vUART_echo+0xa>	UART0_D = dato;								//Imprime dato en pantalla  1e:	f44f 4320 	mov.w	r3, #40960	; 0xa000  22:	f2c4 0306 	movt	r3, #16390	; 0x4006  26:	79fa      	ldrb	r2, [r7, #7]  28:	71da      	strb	r2, [r3, #7]}  2a:	f107 070c 	add.w	r7, r7, #12  2e:	46bd      	mov	sp, r7  30:	bc80      	pop	{r7}  32:	4770      	bx	lrDisassembly of section .text.u8UART_receive:00000000 <u8UART_receive>:unsigned char u8UART_receive(void)			// Metodo para leer datos recibidos{   0:	b480      	push	{r7}   2:	b083      	sub	sp, #12   4:	af00      	add	r7, sp, #0	do {	} while (!(UART1_S1 & UART_S1_RDRF_MASK));   6:	f44f 4330 	mov.w	r3, #45056	; 0xb000   a:	f2c4 0306 	movt	r3, #16390	; 0x4006   e:	791b      	ldrb	r3, [r3, #4]  10:	b2db      	uxtb	r3, r3  12:	f003 0320 	and.w	r3, r3, #32  16:	2b00      	cmp	r3, #0  18:	d0f5      	beq.n	6 <u8UART_receive+0x6>	unsigned char receiveValue = UART1_D; // Lee contenido de UART1_D, lo almacena en receiveValue y lo limpia  1a:	f44f 4330 	mov.w	r3, #45056	; 0xb000  1e:	f2c4 0306 	movt	r3, #16390	; 0x4006  22:	79db      	ldrb	r3, [r3, #7]  24:	71fb      	strb	r3, [r7, #7]	UART0_D = receiveValue;  26:	f44f 4320 	mov.w	r3, #40960	; 0xa000  2a:	f2c4 0306 	movt	r3, #16390	; 0x4006  2e:	79fa      	ldrb	r2, [r7, #7]  30:	71da      	strb	r2, [r3, #7]	return receiveValue;  32:	79fb      	ldrb	r3, [r7, #7]}  34:	4618      	mov	r0, r3  36:	f107 070c 	add.w	r7, r7, #12  3a:	46bd      	mov	sp, r7  3c:	bc80      	pop	{r7}  3e:	4770      	bx	lrDisassembly of section .text.vUART_receive_buffer:00000000 <vUART_receive_buffer>:void vUART_receive_buffer(void)		// Buffer para guardar carcteres entrantes{   0:	b590      	push	{r4, r7, lr}   2:	b083      	sub	sp, #12   4:	af00      	add	r7, sp, #0	unsigned char i = 0;   6:	f04f 0300 	mov.w	r3, #0   a:	70fb      	strb	r3, [r7, #3]	unsigned long cont = 0;   c:	f04f 0300 	mov.w	r3, #0  10:	607b      	str	r3, [r7, #4]	do {		buffer[i] = u8UART_receive();  12:	78fc      	ldrb	r4, [r7, #3]  14:	f7ff fffe 	bl	0 <vUART_receive_buffer>			14: R_ARM_THM_CALL	u8UART_receive  18:	4603      	mov	r3, r0  1a:	461a      	mov	r2, r3  1c:	f240 0300 	movw	r3, #0			1c: R_ARM_THM_MOVW_ABS_NC	buffer  20:	f2c0 0300 	movt	r3, #0			20: R_ARM_THM_MOVT_ABS	buffer  24:	551a      	strb	r2, [r3, r4]	} while ((i < 80) && (++cont <= 10000000));  26:	78fb      	ldrb	r3, [r7, #3]  28:	2b4f      	cmp	r3, #79	; 0x4f  2a:	d80a      	bhi.n	42 <vUART_receive_buffer+0x42>  2c:	687b      	ldr	r3, [r7, #4]  2e:	f103 0301 	add.w	r3, r3, #1  32:	607b      	str	r3, [r7, #4]  34:	687a      	ldr	r2, [r7, #4]  36:	f249 6380 	movw	r3, #38528	; 0x9680  3a:	f2c0 0398 	movt	r3, #152	; 0x98  3e:	429a      	cmp	r2, r3  40:	d9e7      	bls.n	12 <vUART_receive_buffer+0x12>}  42:	f107 070c 	add.w	r7, r7, #12  46:	46bd      	mov	sp, r7  48:	bd90      	pop	{r4, r7, pc}  4a:	bf00      	nopDisassembly of section .text.vUART_send_msg:00000000 <vUART_send_msg>:void vUART_send_msg(unsigned char mens[])		// Envia mensaje al ESP8266{   0:	b580      	push	{r7, lr}   2:	b084      	sub	sp, #16   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]	unsigned char i = 0;   8:	f04f 0300 	mov.w	r3, #0   c:	73fb      	strb	r3, [r7, #15]	do {		vUART_send(mens[i]);   e:	7bfb      	ldrb	r3, [r7, #15]  10:	687a      	ldr	r2, [r7, #4]  12:	18d3      	adds	r3, r2, r3  14:	781b      	ldrb	r3, [r3, #0]  16:	4618      	mov	r0, r3  18:	f7ff fffe 	bl	0 <vUART_send_msg>			18: R_ARM_THM_CALL	vUART_send	} while (mens[++i] != 0);  1c:	7bfb      	ldrb	r3, [r7, #15]  1e:	f103 0301 	add.w	r3, r3, #1  22:	73fb      	strb	r3, [r7, #15]  24:	7bfb      	ldrb	r3, [r7, #15]  26:	687a      	ldr	r2, [r7, #4]  28:	18d3      	adds	r3, r2, r3  2a:	781b      	ldrb	r3, [r3, #0]  2c:	2b00      	cmp	r3, #0  2e:	d1ee      	bne.n	e <vUART_send_msg+0xe>}  30:	f107 0710 	add.w	r7, r7, #16  34:	46bd      	mov	sp, r7  36:	bd80      	pop	{r7, pc}Disassembly of section .text.u8parser:00000000 <u8parser>:unsigned char u8parser(unsigned char cmpmens[])  // Parser busca la palabra "OK"{   0:	b480      	push	{r7}   2:	b085      	sub	sp, #20   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]	unsigned char i = 0;   8:	f04f 0300 	mov.w	r3, #0   c:	73fb      	strb	r3, [r7, #15]	unsigned char j = 0;   e:	f04f 0300 	mov.w	r3, #0  12:	73bb      	strb	r3, [r7, #14]	unsigned char temp;	do {		cont = 0;  14:	f240 0300 	movw	r3, #0			14: R_ARM_THM_MOVW_ABS_NC	cont  18:	f2c0 0300 	movt	r3, #0			18: R_ARM_THM_MOVT_ABS	cont  1c:	f04f 0200 	mov.w	r2, #0  20:	601a      	str	r2, [r3, #0]		do {		} while ((!(UART1_S1 & UART_S1_RDRF_MASK)) && (++cont <= 1000000));  22:	f44f 4330 	mov.w	r3, #45056	; 0xb000  26:	f2c4 0306 	movt	r3, #16390	; 0x4006  2a:	791b      	ldrb	r3, [r3, #4]  2c:	b2db      	uxtb	r3, r3  2e:	f003 0320 	and.w	r3, r3, #32  32:	2b00      	cmp	r3, #0  34:	d116      	bne.n	64 <u8parser+0x64>  36:	f240 0300 	movw	r3, #0			36: R_ARM_THM_MOVW_ABS_NC	cont  3a:	f2c0 0300 	movt	r3, #0			3a: R_ARM_THM_MOVT_ABS	cont  3e:	681b      	ldr	r3, [r3, #0]  40:	f103 0201 	add.w	r2, r3, #1  44:	f240 0300 	movw	r3, #0			44: R_ARM_THM_MOVW_ABS_NC	cont  48:	f2c0 0300 	movt	r3, #0			48: R_ARM_THM_MOVT_ABS	cont  4c:	601a      	str	r2, [r3, #0]  4e:	f240 0300 	movw	r3, #0			4e: R_ARM_THM_MOVW_ABS_NC	cont  52:	f2c0 0300 	movt	r3, #0			52: R_ARM_THM_MOVT_ABS	cont  56:	681a      	ldr	r2, [r3, #0]  58:	f244 2340 	movw	r3, #16960	; 0x4240  5c:	f2c0 030f 	movt	r3, #15  60:	429a      	cmp	r2, r3  62:	d9de      	bls.n	22 <u8parser+0x22>		if (cont <= 1000000) {  64:	f240 0300 	movw	r3, #0			64: R_ARM_THM_MOVW_ABS_NC	cont  68:	f2c0 0300 	movt	r3, #0			68: R_ARM_THM_MOVT_ABS	cont  6c:	681a      	ldr	r2, [r3, #0]  6e:	f244 2340 	movw	r3, #16960	; 0x4240  72:	f2c0 030f 	movt	r3, #15  76:	429a      	cmp	r2, r3  78:	d825      	bhi.n	c6 <u8parser+0xc6>			temp = UART1_D;  7a:	f44f 4330 	mov.w	r3, #45056	; 0xb000  7e:	f2c4 0306 	movt	r3, #16390	; 0x4006  82:	79db      	ldrb	r3, [r3, #7]  84:	737b      	strb	r3, [r7, #13]			UART0_D = temp;  86:	f44f 4320 	mov.w	r3, #40960	; 0xa000  8a:	f2c4 0306 	movt	r3, #16390	; 0x4006  8e:	7b7a      	ldrb	r2, [r7, #13]  90:	71da      	strb	r2, [r3, #7]			buffer[j++] = temp;  92:	7bba      	ldrb	r2, [r7, #14]  94:	f240 0300 	movw	r3, #0			94: R_ARM_THM_MOVW_ABS_NC	buffer  98:	f2c0 0300 	movt	r3, #0			98: R_ARM_THM_MOVT_ABS	buffer  9c:	7b79      	ldrb	r1, [r7, #13]  9e:	5499      	strb	r1, [r3, r2]  a0:	7bbb      	ldrb	r3, [r7, #14]  a2:	f103 0301 	add.w	r3, r3, #1  a6:	73bb      	strb	r3, [r7, #14]			if (cmpmens[i] == temp)  a8:	7bfb      	ldrb	r3, [r7, #15]  aa:	687a      	ldr	r2, [r7, #4]  ac:	18d3      	adds	r3, r2, r3  ae:	781b      	ldrb	r3, [r3, #0]  b0:	7b7a      	ldrb	r2, [r7, #13]  b2:	429a      	cmp	r2, r3  b4:	d104      	bne.n	c0 <u8parser+0xc0>				i++;  b6:	7bfb      	ldrb	r3, [r7, #15]  b8:	f103 0301 	add.w	r3, r3, #1  bc:	73fb      	strb	r3, [r7, #15]  be:	e002      	b.n	c6 <u8parser+0xc6>			else				i = 0;  c0:	f04f 0300 	mov.w	r3, #0  c4:	73fb      	strb	r3, [r7, #15]		}	} while ((cmpmens[i] != 0));  c6:	7bfb      	ldrb	r3, [r7, #15]  c8:	687a      	ldr	r2, [r7, #4]  ca:	18d3      	adds	r3, r2, r3  cc:	781b      	ldrb	r3, [r3, #0]  ce:	2b00      	cmp	r3, #0  d0:	d1a0      	bne.n	14 <u8parser+0x14>	if (cont >= 1000000) {  d2:	f240 0300 	movw	r3, #0			d2: R_ARM_THM_MOVW_ABS_NC	cont  d6:	f2c0 0300 	movt	r3, #0			d6: R_ARM_THM_MOVT_ABS	cont  da:	681a      	ldr	r2, [r3, #0]  dc:	f244 233f 	movw	r3, #16959	; 0x423f  e0:	f2c0 030f 	movt	r3, #15  e4:	429a      	cmp	r2, r3  e6:	d902      	bls.n	ee <u8parser+0xee>		return 0;  e8:	f04f 0300 	mov.w	r3, #0  ec:	e001      	b.n	f2 <u8parser+0xf2>	} else		return 1;  ee:	f04f 0301 	mov.w	r3, #1}  f2:	4618      	mov	r0, r3  f4:	f107 0714 	add.w	r7, r7, #20  f8:	46bd      	mov	sp, r7  fa:	bc80      	pop	{r7}  fc:	4770      	bx	lr  fe:	bf00      	nopDisassembly of section .text.vUART_connect:00000000 <vUART_connect>:void vUART_connect(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0	// LED Rojo: Indica que proceso de conexiones ha empezado	GPIOB_PDDR = 0x00400000;   4:	f24f 0340 	movw	r3, #61504	; 0xf040   8:	f2c4 030f 	movt	r3, #16399	; 0x400f   c:	f44f 0280 	mov.w	r2, #4194304	; 0x400000  10:	615a      	str	r2, [r3, #20]	GPIOE_PDDR = 0x00000000;  12:	f44f 4371 	mov.w	r3, #61696	; 0xf100  16:	f2c4 030f 	movt	r3, #16399	; 0x400f  1a:	f04f 0200 	mov.w	r2, #0  1e:	615a      	str	r2, [r3, #20]	vUART_send_msg(mens[0]);									// Configura CWMODE  20:	f240 0000 	movw	r0, #0			20: R_ARM_THM_MOVW_ABS_NC	mens  24:	f2c0 0000 	movt	r0, #0			24: R_ARM_THM_MOVT_ABS	mens  28:	f7ff fffe 	bl	0 <vUART_connect>			28: R_ARM_THM_CALL	vUART_send_msg	if (u8parser(cmpmens[1]) == 1) {							// Espera respuesta OK	  2c:	4825      	ldr	r0, [pc, #148]	; (98 <vUART_connect+0x98>)  2e:	f7ff fffe 	bl	0 <vUART_connect>			2e: R_ARM_THM_CALL	u8parser  32:	4603      	mov	r3, r0  34:	2b01      	cmp	r3, #1  36:	d143      	bne.n	c0 <vUART_connect+0xc0>		vUART_send_msg(mens[1]);								// Configura red WiFi  38:	4823      	ldr	r0, [pc, #140]	; (c8 <vUART_connect+0xc8>)  3a:	f7ff fffe 	bl	0 <vUART_connect>			3a: R_ARM_THM_CALL	vUART_send_msg		if (u8parser(cmpmens[1]) == 1) {	  					// Espera respuesta OK  3e:	4821      	ldr	r0, [pc, #132]	; (88 <vUART_connect+0x88>)  40:	f7ff fffe 	bl	0 <vUART_connect>			40: R_ARM_THM_CALL	u8parser  44:	4603      	mov	r3, r0  46:	2b01      	cmp	r3, #1  48:	d13a      	bne.n	c0 <vUART_connect+0xc0>			vUART_send_msg(mens[2]);							// Configura IP estatica  4a:	4820      	ldr	r0, [pc, #128]	; (cc <vUART_connect+0xcc>)  4c:	f7ff fffe 	bl	0 <vUART_connect>			4c: R_ARM_THM_CALL	vUART_send_msg			if (u8parser(cmpmens[1]) == 1) {					// Espera respuesta OK  50:	481c      	ldr	r0, [pc, #112]	; (74 <vUART_connect+0x74>)  52:	f7ff fffe 	bl	0 <vUART_connect>			52: R_ARM_THM_CALL	u8parser  56:	4603      	mov	r3, r0  58:	2b01      	cmp	r3, #1  5a:	d131      	bne.n	c0 <vUART_connect+0xc0>				vUART_send_msg(mens[3]);						// Envia mensaje CIFSR para verificar IP  5c:	481c      	ldr	r0, [pc, #112]	; (d0 <vUART_connect+0xd0>)  5e:	f7ff fffe 	bl	0 <vUART_connect>			5e: R_ARM_THM_CALL	vUART_send_msg				if (u8parser(cmpmens[1]) == 1) {				// Espera respuesta OK  62:	4818      	ldr	r0, [pc, #96]	; (64 <vUART_connect+0x64>)  64:	f7ff fffe 	bl	0 <vUART_connect>			64: R_ARM_THM_CALL	u8parser  68:	4603      	mov	r3, r0  6a:	2b01      	cmp	r3, #1  6c:	d128      	bne.n	c0 <vUART_connect+0xc0>					vUART_send_msg(mens[4]);					// Configura modo CIPMUX  6e:	4819      	ldr	r0, [pc, #100]	; (d4 <vUART_connect+0xd4>)  70:	f7ff fffe 	bl	0 <vUART_connect>			70: R_ARM_THM_CALL	vUART_send_msg					if (u8parser(cmpmens[1]) == 1) {			// Espera respuesta OK  74:	4813      	ldr	r0, [pc, #76]	; (50 <vUART_connect+0x50>)  76:	f7ff fffe 	bl	0 <vUART_connect>			76: R_ARM_THM_CALL	u8parser  7a:	4603      	mov	r3, r0  7c:	2b01      	cmp	r3, #1  7e:	d11f      	bne.n	c0 <vUART_connect+0xc0>						vUART_send_msg(mens[5]);				// Levanta el servidor  80:	4815      	ldr	r0, [pc, #84]	; (d8 <vUART_connect+0xd8>)  82:	f7ff fffe 	bl	0 <vUART_connect>			82: R_ARM_THM_CALL	vUART_send_msg						if (u8parser(cmpmens[1]) == 1) {		// Espera OK  86:	480f      	ldr	r0, [pc, #60]	; (40 <vUART_connect+0x40>)  88:	f7ff fffe 	bl	0 <vUART_connect>			88: R_ARM_THM_CALL	u8parser  8c:	4603      	mov	r3, r0  8e:	2b01      	cmp	r3, #1  90:	d116      	bne.n	c0 <vUART_connect+0xc0>							vUART_send_msg(mens[6]);			// Comienza conexion TCP  92:	4812      	ldr	r0, [pc, #72]	; (dc <vUART_connect+0xdc>)  94:	f7ff fffe 	bl	0 <vUART_connect>			94: R_ARM_THM_CALL	vUART_send_msg							if (u8parser(cmpmens[1]) == 1) {	// Espera OK  98:	480a      	ldr	r0, [pc, #40]	; (2c <vUART_connect+0x2c>)  9a:	f7ff fffe 	bl	0 <vUART_connect>			9a: R_ARM_THM_CALL	u8parser  9e:	4603      	mov	r3, r0  a0:	2b01      	cmp	r3, #1  a2:	d10d      	bne.n	c0 <vUART_connect+0xc0>								// LED Verde: Indica que proceso de conexiones ha terminado								GPIOB_PDDR=0x00000000;  a4:	f24f 0340 	movw	r3, #61504	; 0xf040  a8:	f2c4 030f 	movt	r3, #16399	; 0x400f  ac:	f04f 0200 	mov.w	r2, #0  b0:	615a      	str	r2, [r3, #20]								GPIOE_PDDR=0x04000000;  b2:	f44f 4371 	mov.w	r3, #61696	; 0xf100  b6:	f2c4 030f 	movt	r3, #16399	; 0x400f  ba:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000  be:	615a      	str	r2, [r3, #20]							}}}}}}}}  c0:	bd80      	pop	{r7, pc}  c2:	bf00      	nop  c4:	0000000a 	.word	0x0000000a			c4: R_ARM_ABS32	cmpmens  c8:	00000046 	.word	0x00000046			c8: R_ARM_ABS32	mens  cc:	0000008c 	.word	0x0000008c			cc: R_ARM_ABS32	mens  d0:	000000d2 	.word	0x000000d2			d0: R_ARM_ABS32	mens  d4:	00000118 	.word	0x00000118			d4: R_ARM_ABS32	mens  d8:	0000015e 	.word	0x0000015e			d8: R_ARM_ABS32	mens  dc:	000001a4 	.word	0x000001a4			dc: R_ARM_ABS32	mensDisassembly of section .text.vUART_update_process:00000000 <vUART_update_process>:void vUART_update_process(void){   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0	vUART_send_msg(mens[7]); 								// Envia comando CIPSEND   4:	4886      	ldr	r0, [pc, #536]	; (220 <vUART_update_process+0x220>)   6:	f7ff fffe 	bl	0 <vUART_update_process>			6: R_ARM_THM_CALL	vUART_send_msg	// Comando de ON/OFF	if (LED != 'S' && LED != 'M') {	   a:	f240 0300 	movw	r3, #0			a: R_ARM_THM_MOVW_ABS_NC	LED   e:	f2c0 0300 	movt	r3, #0			e: R_ARM_THM_MOVT_ABS	LED  12:	781b      	ldrb	r3, [r3, #0]  14:	2b53      	cmp	r3, #83	; 0x53  16:	d073      	beq.n	100 <vUART_update_process+0x100>  18:	f240 0300 	movw	r3, #0			18: R_ARM_THM_MOVW_ABS_NC	LED  1c:	f2c0 0300 	movt	r3, #0			1c: R_ARM_THM_MOVT_ABS	LED  20:	781b      	ldrb	r3, [r3, #0]  22:	2b4d      	cmp	r3, #77	; 0x4d  24:	d06c      	beq.n	100 <vUART_update_process+0x100>		if (u8parser(cmpmens[1]) == 1) { 					// Espera OK  26:	487f      	ldr	r0, [pc, #508]	; (224 <vUART_update_process+0x224>)  28:	f7ff fffe 	bl	0 <vUART_update_process>			28: R_ARM_THM_CALL	u8parser  2c:	4603      	mov	r3, r0  2e:	2b01      	cmp	r3, #1  30:	d166      	bne.n	100 <vUART_update_process+0x100>			if (u8parser(cmpmens[3]) == 1) {				// Espera >  32:	487d      	ldr	r0, [pc, #500]	; (228 <vUART_update_process+0x228>)  34:	f7ff fffe 	bl	0 <vUART_update_process>			34: R_ARM_THM_CALL	u8parser  38:	4603      	mov	r3, r0  3a:	2b01      	cmp	r3, #1  3c:	d160      	bne.n	100 <vUART_update_process+0x100>				switch (automatico) {  3e:	f240 0300 	movw	r3, #0			3e: R_ARM_THM_MOVW_ABS_NC	automatico  42:	f2c0 0300 	movt	r3, #0			42: R_ARM_THM_MOVT_ABS	automatico  46:	781b      	ldrb	r3, [r3, #0]  48:	2b30      	cmp	r3, #48	; 0x30  4a:	d01e      	beq.n	8a <vUART_update_process+0x8a>  4c:	2b31      	cmp	r3, #49	; 0x31  4e:	d135      	bne.n	bc <vUART_update_process+0xbc>				case '1':					if (adc_value < ON)  50:	f240 0300 	movw	r3, #0			50: R_ARM_THM_MOVW_ABS_NC	adc_value  54:	f2c0 0300 	movt	r3, #0			54: R_ARM_THM_MOVT_ABS	adc_value  58:	681a      	ldr	r2, [r3, #0]  5a:	f247 532f 	movw	r3, #29999	; 0x752f  5e:	429a      	cmp	r2, r3  60:	d803      	bhi.n	6a <vUART_update_process+0x6a>						vUART_send_msg(mensStatus[1]); 		// Envia query ON  62:	4872      	ldr	r0, [pc, #456]	; (22c <vUART_update_process+0x22c>)  64:	f7ff fffe 	bl	0 <vUART_update_process>			64: R_ARM_THM_CALL	vUART_send_msg					else if (adc_value > ON)						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;  68:	e045      	b.n	92 <vUART_update_process+0x92>				switch (automatico) {				case '1':					if (adc_value < ON)						vUART_send_msg(mensStatus[1]); 		// Envia query ON					else if (adc_value > ON)  6a:	f240 0300 	movw	r3, #0			6a: R_ARM_THM_MOVW_ABS_NC	adc_value  6e:	f2c0 0300 	movt	r3, #0			6e: R_ARM_THM_MOVT_ABS	adc_value  72:	681a      	ldr	r2, [r3, #0]  74:	f247 5330 	movw	r3, #30000	; 0x7530  78:	429a      	cmp	r2, r3  7a:	d93c      	bls.n	f6 <vUART_update_process+0xf6>						vUART_send_msg(mensStatus[0]); 		// Envia query OFF  7c:	f240 0000 	movw	r0, #0			7c: R_ARM_THM_MOVW_ABS_NC	mensStatus  80:	f2c0 0000 	movt	r0, #0			80: R_ARM_THM_MOVT_ABS	mensStatus  84:	f7ff fffe 	bl	0 <vUART_update_process>			84: R_ARM_THM_CALL	vUART_send_msg					break;  88:	e035      	b.n	6f <vUART_update_process+0x6f>				case '0':					if (isOn == 'Y')  8a:	f240 0300 	movw	r3, #0			8a: R_ARM_THM_MOVW_ABS_NC	isOn  8e:	f2c0 0300 	movt	r3, #0			8e: R_ARM_THM_MOVT_ABS	isOn  92:	781b      	ldrb	r3, [r3, #0]  94:	2b59      	cmp	r3, #89	; 0x59  96:	d103      	bne.n	a0 <vUART_update_process+0xa0>						vUART_send_msg(mensStatus[1]); 		// Envia query ON  98:	4864      	ldr	r0, [pc, #400]	; (22c <vUART_update_process+0x22c>)  9a:	f7ff fffe 	bl	0 <vUART_update_process>			9a: R_ARM_THM_CALL	vUART_send_msg					else if (isOn == 'N')						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;  9e:	e02c      	b.n	5d <vUART_update_process+0x5d>						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;				case '0':					if (isOn == 'Y')						vUART_send_msg(mensStatus[1]); 		// Envia query ON					else if (isOn == 'N')  a0:	f240 0300 	movw	r3, #0			a0: R_ARM_THM_MOVW_ABS_NC	isOn  a4:	f2c0 0300 	movt	r3, #0			a4: R_ARM_THM_MOVT_ABS	isOn  a8:	781b      	ldrb	r3, [r3, #0]  aa:	2b4e      	cmp	r3, #78	; 0x4e  ac:	d125      	bne.n	fa <vUART_update_process+0xfa>						vUART_send_msg(mensStatus[0]); 		// Envia query OFF  ae:	f240 0000 	movw	r0, #0			ae: R_ARM_THM_MOVW_ABS_NC	mensStatus  b2:	f2c0 0000 	movt	r0, #0			b2: R_ARM_THM_MOVT_ABS	mensStatus  b6:	f7ff fffe 	bl	0 <vUART_update_process>			b6: R_ARM_THM_CALL	vUART_send_msg					break;  ba:	e01e      	b.n	44 <vUART_update_process+0x44>				default:					if (adc_value < ON)  bc:	f240 0300 	movw	r3, #0			bc: R_ARM_THM_MOVW_ABS_NC	adc_value  c0:	f2c0 0300 	movt	r3, #0			c0: R_ARM_THM_MOVT_ABS	adc_value  c4:	681a      	ldr	r2, [r3, #0]  c6:	f247 532f 	movw	r3, #29999	; 0x752f  ca:	429a      	cmp	r2, r3  cc:	d803      	bhi.n	d6 <vUART_update_process+0xd6>						vUART_send_msg(mensStatus[1]); 		// Envia query ON  ce:	4857      	ldr	r0, [pc, #348]	; (22c <vUART_update_process+0x22c>)  d0:	f7ff fffe 	bl	0 <vUART_update_process>			d0: R_ARM_THM_CALL	vUART_send_msg					else if (adc_value > ON)						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;  d4:	e013      	b.n	2e <vUART_update_process+0x2e>						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;				default:					if (adc_value < ON)						vUART_send_msg(mensStatus[1]); 		// Envia query ON					else if (adc_value > ON)  d6:	f240 0300 	movw	r3, #0			d6: R_ARM_THM_MOVW_ABS_NC	adc_value  da:	f2c0 0300 	movt	r3, #0			da: R_ARM_THM_MOVT_ABS	adc_value  de:	681a      	ldr	r2, [r3, #0]  e0:	f247 5330 	movw	r3, #30000	; 0x7530  e4:	429a      	cmp	r2, r3  e6:	d90a      	bls.n	fe <vUART_update_process+0xfe>						vUART_send_msg(mensStatus[0]); 		// Envia query OFF  e8:	f240 0000 	movw	r0, #0			e8: R_ARM_THM_MOVW_ABS_NC	mensStatus  ec:	f2c0 0000 	movt	r0, #0			ec: R_ARM_THM_MOVT_ABS	mensStatus  f0:	f7ff fffe 	bl	0 <vUART_update_process>			f0: R_ARM_THM_CALL	vUART_send_msg					break;  f4:	e003      	b.n	fe <vUART_update_process+0xfe>				case '1':					if (adc_value < ON)						vUART_send_msg(mensStatus[1]); 		// Envia query ON					else if (adc_value > ON)						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;  f6:	bf00      	nop  f8:	e002      	b.n	100 <vUART_update_process+0x100>				case '0':					if (isOn == 'Y')						vUART_send_msg(mensStatus[1]); 		// Envia query ON					else if (isOn == 'N')						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;  fa:	bf00      	nop  fc:	e000      	b.n	100 <vUART_update_process+0x100>				default:					if (adc_value < ON)						vUART_send_msg(mensStatus[1]); 		// Envia query ON					else if (adc_value > ON)						vUART_send_msg(mensStatus[0]); 		// Envia query OFF					break;  fe:	bf00      	nop		}	}	//Abrir conexin en caso de cerrada	if (u8parser(cmpmens[4]) == 1){									// Espera OK 100:	484b      	ldr	r0, [pc, #300]	; (230 <vUART_update_process+0x230>) 102:	f7ff fffe 	bl	0 <vUART_update_process>			102: R_ARM_THM_CALL	u8parser 106:	4603      	mov	r3, r0 108:	2b01      	cmp	r3, #1 10a:	d105      	bne.n	118 <vUART_update_process+0x118>		vUART_send_msg(mens[6]);									// Comienza conexion TCP 10c:	4849      	ldr	r0, [pc, #292]	; (234 <vUART_update_process+0x234>) 10e:	f7ff fffe 	bl	0 <vUART_update_process>			10e: R_ARM_THM_CALL	vUART_send_msg		if (u8parser(cmpmens[1]) == 1){}							// Espera OK 112:	4844      	ldr	r0, [pc, #272]	; (114 <vUART_update_process+0x114>) 114:	f7ff fffe 	bl	0 <vUART_update_process>			114: R_ARM_THM_CALL	u8parser	}	//Recibe Equipo2	if (u8parser(cmpmens[2]) == 1) { 118:	4847      	ldr	r0, [pc, #284]	; (120 <vUART_update_process+0x120>) 11a:	f7ff fffe 	bl	0 <vUART_update_process>			11a: R_ARM_THM_CALL	u8parser 11e:	4603      	mov	r3, r0 120:	2b01      	cmp	r3, #1 122:	d17b      	bne.n	21c <vUART_update_process+0x21c>		LED = u8UART_receive(); 124:	f7ff fffe 	bl	0 <vUART_update_process>			124: R_ARM_THM_CALL	u8UART_receive 128:	4603      	mov	r3, r0 12a:	461a      	mov	r2, r3 12c:	f240 0300 	movw	r3, #0			12c: R_ARM_THM_MOVW_ABS_NC	LED 130:	f2c0 0300 	movt	r3, #0			130: R_ARM_THM_MOVT_ABS	LED 134:	701a      	strb	r2, [r3, #0]		if (LED == 'M') { 136:	f240 0300 	movw	r3, #0			136: R_ARM_THM_MOVW_ABS_NC	LED 13a:	f2c0 0300 	movt	r3, #0			13a: R_ARM_THM_MOVT_ABS	LED 13e:	781b      	ldrb	r3, [r3, #0] 140:	2b4d      	cmp	r3, #77	; 0x4d 142:	d107      	bne.n	154 <vUART_update_process+0x154>			automatico = '0'; 144:	f240 0300 	movw	r3, #0			144: R_ARM_THM_MOVW_ABS_NC	automatico 148:	f2c0 0300 	movt	r3, #0			148: R_ARM_THM_MOVT_ABS	automatico 14c:	f04f 0230 	mov.w	r2, #48	; 0x30 150:	701a      	strb	r2, [r3, #0] 152:	e063      	b.n	21c <vUART_update_process+0x21c>		} else if (LED == 'S') { 154:	f240 0300 	movw	r3, #0			154: R_ARM_THM_MOVW_ABS_NC	LED 158:	f2c0 0300 	movt	r3, #0			158: R_ARM_THM_MOVT_ABS	LED 15c:	781b      	ldrb	r3, [r3, #0] 15e:	2b53      	cmp	r3, #83	; 0x53 160:	d107      	bne.n	172 <vUART_update_process+0x172>			automatico = '1'; 162:	f240 0300 	movw	r3, #0			162: R_ARM_THM_MOVW_ABS_NC	automatico 166:	f2c0 0300 	movt	r3, #0			166: R_ARM_THM_MOVT_ABS	automatico 16a:	f04f 0231 	mov.w	r2, #49	; 0x31 16e:	701a      	strb	r2, [r3, #0] 170:	e054      	b.n	21c <vUART_update_process+0x21c>		} else if (LED == 'R' && automatico == '0') { 172:	f240 0300 	movw	r3, #0			172: R_ARM_THM_MOVW_ABS_NC	LED 176:	f2c0 0300 	movt	r3, #0			176: R_ARM_THM_MOVT_ABS	LED 17a:	781b      	ldrb	r3, [r3, #0] 17c:	2b52      	cmp	r3, #82	; 0x52 17e:	d123      	bne.n	1c8 <vUART_update_process+0x1c8> 180:	f240 0300 	movw	r3, #0			180: R_ARM_THM_MOVW_ABS_NC	automatico 184:	f2c0 0300 	movt	r3, #0			184: R_ARM_THM_MOVT_ABS	automatico 188:	781b      	ldrb	r3, [r3, #0] 18a:	2b30      	cmp	r3, #48	; 0x30 18c:	d11c      	bne.n	1c8 <vUART_update_process+0x1c8>			GPIOC_PDOR = 0x0; 18e:	f24f 0380 	movw	r3, #61568	; 0xf080 192:	f2c4 030f 	movt	r3, #16399	; 0x400f 196:	f04f 0200 	mov.w	r2, #0 19a:	601a      	str	r2, [r3, #0]			GPIOB_PDDR = 0x00400000; 19c:	f24f 0340 	movw	r3, #61504	; 0xf040 1a0:	f2c4 030f 	movt	r3, #16399	; 0x400f 1a4:	f44f 0280 	mov.w	r2, #4194304	; 0x400000 1a8:	615a      	str	r2, [r3, #20]			GPIOE_PDDR = 0x00000000; 1aa:	f44f 4371 	mov.w	r3, #61696	; 0xf100 1ae:	f2c4 030f 	movt	r3, #16399	; 0x400f 1b2:	f04f 0200 	mov.w	r2, #0 1b6:	615a      	str	r2, [r3, #20]			isOn = 'Y'; 1b8:	f240 0300 	movw	r3, #0			1b8: R_ARM_THM_MOVW_ABS_NC	isOn 1bc:	f2c0 0300 	movt	r3, #0			1bc: R_ARM_THM_MOVT_ABS	isOn 1c0:	f04f 0259 	mov.w	r2, #89	; 0x59 1c4:	701a      	strb	r2, [r3, #0] 1c6:	e029      	b.n	21c <vUART_update_process+0x21c>		} else if (LED == 'A' && automatico == '0') { 1c8:	f240 0300 	movw	r3, #0			1c8: R_ARM_THM_MOVW_ABS_NC	LED 1cc:	f2c0 0300 	movt	r3, #0			1cc: R_ARM_THM_MOVT_ABS	LED 1d0:	781b      	ldrb	r3, [r3, #0] 1d2:	2b41      	cmp	r3, #65	; 0x41 1d4:	d122      	bne.n	21c <vUART_update_process+0x21c> 1d6:	f240 0300 	movw	r3, #0			1d6: R_ARM_THM_MOVW_ABS_NC	automatico 1da:	f2c0 0300 	movt	r3, #0			1da: R_ARM_THM_MOVT_ABS	automatico 1de:	781b      	ldrb	r3, [r3, #0] 1e0:	2b30      	cmp	r3, #48	; 0x30 1e2:	d11b      	bne.n	21c <vUART_update_process+0x21c>			GPIOC_PDOR = (1 << 2); 1e4:	f24f 0380 	movw	r3, #61568	; 0xf080 1e8:	f2c4 030f 	movt	r3, #16399	; 0x400f 1ec:	f04f 0204 	mov.w	r2, #4 1f0:	601a      	str	r2, [r3, #0]			GPIOB_PDDR = 0x00000000; 1f2:	f24f 0340 	movw	r3, #61504	; 0xf040 1f6:	f2c4 030f 	movt	r3, #16399	; 0x400f 1fa:	f04f 0200 	mov.w	r2, #0 1fe:	615a      	str	r2, [r3, #20]			GPIOE_PDDR = 0x00000000; 200:	f44f 4371 	mov.w	r3, #61696	; 0xf100 204:	f2c4 030f 	movt	r3, #16399	; 0x400f 208:	f04f 0200 	mov.w	r2, #0 20c:	615a      	str	r2, [r3, #20]			isOn = 'N'; 20e:	f240 0300 	movw	r3, #0			20e: R_ARM_THM_MOVW_ABS_NC	isOn 212:	f2c0 0300 	movt	r3, #0			212: R_ARM_THM_MOVT_ABS	isOn 216:	f04f 024e 	mov.w	r2, #78	; 0x4e 21a:	701a      	strb	r2, [r3, #0]		}	}} 21c:	bd80      	pop	{r7, pc} 21e:	bf00      	nop 220:	000001ea 	.word	0x000001ea			220: R_ARM_ABS32	mens 224:	0000000a 	.word	0x0000000a			224: R_ARM_ABS32	cmpmens 228:	0000001e 	.word	0x0000001e			228: R_ARM_ABS32	cmpmens 22c:	00000046 	.word	0x00000046			22c: R_ARM_ABS32	mensStatus 230:	00000028 	.word	0x00000028			230: R_ARM_ABS32	cmpmens 234:	000001a4 	.word	0x000001a4			234: R_ARM_ABS32	mens 238:	00000014 	.word	0x00000014			238: R_ARM_ABS32	cmpmensDisassembly of section .text.main:00000000 <main>:int main(void) {   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0	vUART_init();										// Inicializa los Pins   4:	f7ff fffe 	bl	0 <main>			4: R_ARM_THM_CALL	vUART_init	vUART_connect();									// Realiza conexiones iniciales   8:	f7ff fffe 	bl	0 <main>			8: R_ARM_THM_CALL	vUART_connect	vADC_LPTMR_init();   c:	f7ff fffe 	bl	0 <main>			c: R_ARM_THM_CALL	vADC_LPTMR_init		automatico='1';  10:	f240 0300 	movw	r3, #0			10: R_ARM_THM_MOVW_ABS_NC	automatico  14:	f2c0 0300 	movt	r3, #0			14: R_ARM_THM_MOVT_ABS	automatico  18:	f04f 0231 	mov.w	r2, #49	; 0x31  1c:	701a      	strb	r2, [r3, #0]	LED='A';  1e:	f240 0300 	movw	r3, #0			1e: R_ARM_THM_MOVW_ABS_NC	LED  22:	f2c0 0300 	movt	r3, #0			22: R_ARM_THM_MOVT_ABS	LED  26:	f04f 0241 	mov.w	r2, #65	; 0x41  2a:	701a      	strb	r2, [r3, #0]	isOn='N';  2c:	f240 0300 	movw	r3, #0			2c: R_ARM_THM_MOVW_ABS_NC	isOn  30:	f2c0 0300 	movt	r3, #0			30: R_ARM_THM_MOVT_ABS	isOn  34:	f04f 024e 	mov.w	r2, #78	; 0x4e  38:	701a      	strb	r2, [r3, #0]	status_act='0';  3a:	f240 0300 	movw	r3, #0			3a: R_ARM_THM_MOVW_ABS_NC	status_act  3e:	f2c0 0300 	movt	r3, #0			3e: R_ARM_THM_MOVT_ABS	status_act  42:	f04f 0230 	mov.w	r2, #48	; 0x30  46:	701a      	strb	r2, [r3, #0]	status_prev='0';  48:	f240 0300 	movw	r3, #0			48: R_ARM_THM_MOVW_ABS_NC	status_prev  4c:	f2c0 0300 	movt	r3, #0			4c: R_ARM_THM_MOVT_ABS	status_prev  50:	f04f 0230 	mov.w	r2, #48	; 0x30  54:	701a      	strb	r2, [r3, #0]	adc_value=30001;  56:	f240 0300 	movw	r3, #0			56: R_ARM_THM_MOVW_ABS_NC	adc_value  5a:	f2c0 0300 	movt	r3, #0			5a: R_ARM_THM_MOVT_ABS	adc_value  5e:	f247 5231 	movw	r2, #30001	; 0x7531  62:	601a      	str	r2, [r3, #0]  64:	e000      	b.n	68 <main+0x68>		while(1){		if((status_act != status_prev) && (automatico == '1')){			vUART_update_process();			}	}  66:	bf00      	nop	status_prev='0';	adc_value=30001;			while(1){		if((status_act != status_prev) && (automatico == '1')){  68:	f240 0300 	movw	r3, #0			68: R_ARM_THM_MOVW_ABS_NC	status_act  6c:	f2c0 0300 	movt	r3, #0			6c: R_ARM_THM_MOVT_ABS	status_act  70:	781a      	ldrb	r2, [r3, #0]  72:	f240 0300 	movw	r3, #0			72: R_ARM_THM_MOVW_ABS_NC	status_prev  76:	f2c0 0300 	movt	r3, #0			76: R_ARM_THM_MOVT_ABS	status_prev  7a:	781b      	ldrb	r3, [r3, #0]  7c:	429a      	cmp	r2, r3  7e:	d0f2      	beq.n	66 <main+0x66>  80:	f240 0300 	movw	r3, #0			80: R_ARM_THM_MOVW_ABS_NC	automatico  84:	f2c0 0300 	movt	r3, #0			84: R_ARM_THM_MOVT_ABS	automatico  88:	781b      	ldrb	r3, [r3, #0]  8a:	2b31      	cmp	r3, #49	; 0x31  8c:	d1eb      	bne.n	66 <main+0x66>			vUART_update_process();	  8e:	f7ff fffe 	bl	0 <main>			8e: R_ARM_THM_CALL	vUART_update_process		}	}  92:	e7e8      	b.n	66 <main+0x66>Disassembly of section .text.LPTimer_IRQHandler:00000000 <LPTimer_IRQHandler>:	return 0;}void LPTimer_IRQHandler(void) {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0	LPTMR0_CSR |= (1 << 7); //Apagar bandera TIMER   4:	f04f 0300 	mov.w	r3, #0   8:	f2c4 0304 	movt	r3, #16388	; 0x4004   c:	f04f 0200 	mov.w	r2, #0  10:	f2c4 0204 	movt	r2, #16388	; 0x4004  14:	6812      	ldr	r2, [r2, #0]  16:	f042 0280 	orr.w	r2, r2, #128	; 0x80  1a:	601a      	str	r2, [r3, #0]	ADC1_SC1A =(1<<6)+18;  1c:	f44f 4330 	mov.w	r3, #45056	; 0xb000  20:	f2c4 030b 	movt	r3, #16395	; 0x400b  24:	f04f 0252 	mov.w	r2, #82	; 0x52  28:	601a      	str	r2, [r3, #0]}  2a:	46bd      	mov	sp, r7  2c:	bc80      	pop	{r7}  2e:	4770      	bx	lrDisassembly of section .text.ADC1_IRQHandler:00000000 <ADC1_IRQHandler>:void ADC1_IRQHandler(void) {   0:	b580      	push	{r7, lr}   2:	b082      	sub	sp, #8   4:	af00      	add	r7, sp, #0	ADC1_SC1A =(1<<7)+0x1F;	//coco   6:	f44f 4330 	mov.w	r3, #45056	; 0xb000   a:	f2c4 030b 	movt	r3, #16395	; 0x400b   e:	f04f 029f 	mov.w	r2, #159	; 0x9f  12:	601a      	str	r2, [r3, #0]	adc_value = ADC1_RA;//  14:	f44f 4330 	mov.w	r3, #45056	; 0xb000  18:	f2c4 030b 	movt	r3, #16395	; 0x400b  1c:	691a      	ldr	r2, [r3, #16]  1e:	f240 0300 	movw	r3, #0			1e: R_ARM_THM_MOVW_ABS_NC	adc_value  22:	f2c0 0300 	movt	r3, #0			22: R_ARM_THM_MOVT_ABS	adc_value  26:	601a      	str	r2, [r3, #0]	if(automatico == '1'){  28:	f240 0300 	movw	r3, #0			28: R_ARM_THM_MOVW_ABS_NC	automatico  2c:	f2c0 0300 	movt	r3, #0			2c: R_ARM_THM_MOVT_ABS	automatico  30:	781b      	ldrb	r3, [r3, #0]  32:	2b31      	cmp	r3, #49	; 0x31  34:	d150      	bne.n	d8 <ADC1_IRQHandler+0xd8>		if (adc_value<ON) {  36:	f240 0300 	movw	r3, #0			36: R_ARM_THM_MOVW_ABS_NC	adc_value  3a:	f2c0 0300 	movt	r3, #0			3a: R_ARM_THM_MOVT_ABS	adc_value  3e:	681a      	ldr	r2, [r3, #0]  40:	f247 532f 	movw	r3, #29999	; 0x752f  44:	429a      	cmp	r2, r3  46:	d81f      	bhi.n	88 <ADC1_IRQHandler+0x88>			GPIOB_PDOR=0x00000000;			//Encender  48:	f24f 0340 	movw	r3, #61504	; 0xf040  4c:	f2c4 030f 	movt	r3, #16399	; 0x400f  50:	f04f 0200 	mov.w	r2, #0  54:	601a      	str	r2, [r3, #0]			GPIOC_PDOR=0x0;  56:	f24f 0380 	movw	r3, #61568	; 0xf080  5a:	f2c4 030f 	movt	r3, #16399	; 0x400f  5e:	f04f 0200 	mov.w	r2, #0  62:	601a      	str	r2, [r3, #0]			status_prev=status_act;			//Guardar el status anterior  64:	f240 0300 	movw	r3, #0			64: R_ARM_THM_MOVW_ABS_NC	status_act  68:	f2c0 0300 	movt	r3, #0			68: R_ARM_THM_MOVT_ABS	status_act  6c:	781a      	ldrb	r2, [r3, #0]  6e:	f240 0300 	movw	r3, #0			6e: R_ARM_THM_MOVW_ABS_NC	status_prev  72:	f2c0 0300 	movt	r3, #0			72: R_ARM_THM_MOVT_ABS	status_prev  76:	701a      	strb	r2, [r3, #0]			status_act=1;  78:	f240 0300 	movw	r3, #0			78: R_ARM_THM_MOVW_ABS_NC	status_act  7c:	f2c0 0300 	movt	r3, #0			7c: R_ARM_THM_MOVT_ABS	status_act  80:	f04f 0201 	mov.w	r2, #1  84:	701a      	strb	r2, [r3, #0]  86:	e027      	b.n	d8 <ADC1_IRQHandler+0xd8>		}		else if(adc_value>ON) {  88:	f240 0300 	movw	r3, #0			88: R_ARM_THM_MOVW_ABS_NC	adc_value  8c:	f2c0 0300 	movt	r3, #0			8c: R_ARM_THM_MOVT_ABS	adc_value  90:	681a      	ldr	r2, [r3, #0]  92:	f247 5330 	movw	r3, #30000	; 0x7530  96:	429a      	cmp	r2, r3  98:	d91e      	bls.n	d8 <ADC1_IRQHandler+0xd8>			GPIOB_PDOR=(1<<21);				// Apagar  9a:	f24f 0340 	movw	r3, #61504	; 0xf040  9e:	f2c4 030f 	movt	r3, #16399	; 0x400f  a2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000  a6:	601a      	str	r2, [r3, #0]			GPIOC_PDOR=(1<<2);  a8:	f24f 0380 	movw	r3, #61568	; 0xf080  ac:	f2c4 030f 	movt	r3, #16399	; 0x400f  b0:	f04f 0204 	mov.w	r2, #4  b4:	601a      	str	r2, [r3, #0]			status_prev=status_act;			//Guardar el status anterior  b6:	f240 0300 	movw	r3, #0			b6: R_ARM_THM_MOVW_ABS_NC	status_act  ba:	f2c0 0300 	movt	r3, #0			ba: R_ARM_THM_MOVT_ABS	status_act  be:	781a      	ldrb	r2, [r3, #0]  c0:	f240 0300 	movw	r3, #0			c0: R_ARM_THM_MOVW_ABS_NC	status_prev  c4:	f2c0 0300 	movt	r3, #0			c4: R_ARM_THM_MOVT_ABS	status_prev  c8:	701a      	strb	r2, [r3, #0]			status_act=0;  ca:	f240 0300 	movw	r3, #0			ca: R_ARM_THM_MOVW_ABS_NC	status_act  ce:	f2c0 0300 	movt	r3, #0			ce: R_ARM_THM_MOVT_ABS	status_act  d2:	f04f 0200 	mov.w	r2, #0  d6:	701a      	strb	r2, [r3, #0]		}	}	//Prepararse para enviar Ascii	captura[5]=(adc_value/10000);  d8:	f240 0300 	movw	r3, #0			d8: R_ARM_THM_MOVW_ABS_NC	adc_value  dc:	f2c0 0300 	movt	r3, #0			dc: R_ARM_THM_MOVT_ABS	adc_value  e0:	681a      	ldr	r2, [r3, #0]  e2:	f241 7359 	movw	r3, #5977	; 0x1759  e6:	f2cd 13b7 	movt	r3, #53687	; 0xd1b7  ea:	fba3 1302 	umull	r1, r3, r3, r2  ee:	ea4f 3253 	mov.w	r2, r3, lsr #13  f2:	f240 0300 	movw	r3, #0			f2: R_ARM_THM_MOVW_ABS_NC	captura  f6:	f2c0 0300 	movt	r3, #0			f6: R_ARM_THM_MOVT_ABS	captura  fa:	615a      	str	r2, [r3, #20]	captura[4]=((adc_value-(captura[5]*10000))/1000);  fc:	f240 0300 	movw	r3, #0			fc: R_ARM_THM_MOVW_ABS_NC	adc_value 100:	f2c0 0300 	movt	r3, #0			100: R_ARM_THM_MOVT_ABS	adc_value 104:	681a      	ldr	r2, [r3, #0] 106:	f240 0300 	movw	r3, #0			106: R_ARM_THM_MOVW_ABS_NC	captura 10a:	f2c0 0300 	movt	r3, #0			10a: R_ARM_THM_MOVT_ABS	captura 10e:	695b      	ldr	r3, [r3, #20] 110:	f242 7110 	movw	r1, #10000	; 0x2710 114:	fb01 f303 	mul.w	r3, r1, r3 118:	1ad2      	subs	r2, r2, r3 11a:	f644 53d3 	movw	r3, #19923	; 0x4dd3 11e:	f2c1 0362 	movt	r3, #4194	; 0x1062 122:	fba3 1302 	umull	r1, r3, r3, r2 126:	ea4f 1293 	mov.w	r2, r3, lsr #6 12a:	f240 0300 	movw	r3, #0			12a: R_ARM_THM_MOVW_ABS_NC	captura 12e:	f2c0 0300 	movt	r3, #0			12e: R_ARM_THM_MOVT_ABS	captura 132:	611a      	str	r2, [r3, #16]	captura[3]=((adc_value-((captura[5]*10000)+(captura[4]*1000)))/100); 134:	f240 0300 	movw	r3, #0			134: R_ARM_THM_MOVW_ABS_NC	adc_value 138:	f2c0 0300 	movt	r3, #0			138: R_ARM_THM_MOVT_ABS	adc_value 13c:	681a      	ldr	r2, [r3, #0] 13e:	f240 0300 	movw	r3, #0			13e: R_ARM_THM_MOVW_ABS_NC	captura 142:	f2c0 0300 	movt	r3, #0			142: R_ARM_THM_MOVT_ABS	captura 146:	695b      	ldr	r3, [r3, #20] 148:	f242 7110 	movw	r1, #10000	; 0x2710 14c:	fb01 f103 	mul.w	r1, r1, r3 150:	f240 0300 	movw	r3, #0			150: R_ARM_THM_MOVW_ABS_NC	captura 154:	f2c0 0300 	movt	r3, #0			154: R_ARM_THM_MOVT_ABS	captura 158:	691b      	ldr	r3, [r3, #16] 15a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8 15e:	fb00 f303 	mul.w	r3, r0, r3 162:	18cb      	adds	r3, r1, r3 164:	1ad2      	subs	r2, r2, r3 166:	f248 531f 	movw	r3, #34079	; 0x851f 16a:	f2c5 13eb 	movt	r3, #20971	; 0x51eb 16e:	fba3 1302 	umull	r1, r3, r3, r2 172:	ea4f 1253 	mov.w	r2, r3, lsr #5 176:	f240 0300 	movw	r3, #0			176: R_ARM_THM_MOVW_ABS_NC	captura 17a:	f2c0 0300 	movt	r3, #0			17a: R_ARM_THM_MOVT_ABS	captura 17e:	60da      	str	r2, [r3, #12]	captura[2]=((adc_value-((captura[5]*10000)+(captura[4]*1000)+(captura[3]*100)))/10); 180:	f240 0300 	movw	r3, #0			180: R_ARM_THM_MOVW_ABS_NC	adc_value 184:	f2c0 0300 	movt	r3, #0			184: R_ARM_THM_MOVT_ABS	adc_value 188:	681a      	ldr	r2, [r3, #0] 18a:	f240 0300 	movw	r3, #0			18a: R_ARM_THM_MOVW_ABS_NC	captura 18e:	f2c0 0300 	movt	r3, #0			18e: R_ARM_THM_MOVT_ABS	captura 192:	695b      	ldr	r3, [r3, #20] 194:	f242 7110 	movw	r1, #10000	; 0x2710 198:	fb01 f103 	mul.w	r1, r1, r3 19c:	f240 0300 	movw	r3, #0			19c: R_ARM_THM_MOVW_ABS_NC	captura 1a0:	f2c0 0300 	movt	r3, #0			1a0: R_ARM_THM_MOVT_ABS	captura 1a4:	691b      	ldr	r3, [r3, #16] 1a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8 1aa:	fb00 f303 	mul.w	r3, r0, r3 1ae:	18c9      	adds	r1, r1, r3 1b0:	f240 0300 	movw	r3, #0			1b0: R_ARM_THM_MOVW_ABS_NC	captura 1b4:	f2c0 0300 	movt	r3, #0			1b4: R_ARM_THM_MOVT_ABS	captura 1b8:	68db      	ldr	r3, [r3, #12] 1ba:	f04f 0064 	mov.w	r0, #100	; 0x64 1be:	fb00 f303 	mul.w	r3, r0, r3 1c2:	18cb      	adds	r3, r1, r3 1c4:	1ad2      	subs	r2, r2, r3 1c6:	f64c 43cd 	movw	r3, #52429	; 0xcccd 1ca:	f6cc 43cc 	movt	r3, #52428	; 0xcccc 1ce:	fba3 1302 	umull	r1, r3, r3, r2 1d2:	ea4f 02d3 	mov.w	r2, r3, lsr #3 1d6:	f240 0300 	movw	r3, #0			1d6: R_ARM_THM_MOVW_ABS_NC	captura 1da:	f2c0 0300 	movt	r3, #0			1da: R_ARM_THM_MOVT_ABS	captura 1de:	609a      	str	r2, [r3, #8]	captura[0]=(captura[5]*10000)+(captura[4]*1000)+(captura[3]*100)+(captura[2]*10); 1e0:	f240 0300 	movw	r3, #0			1e0: R_ARM_THM_MOVW_ABS_NC	captura 1e4:	f2c0 0300 	movt	r3, #0			1e4: R_ARM_THM_MOVT_ABS	captura 1e8:	695b      	ldr	r3, [r3, #20] 1ea:	f242 7210 	movw	r2, #10000	; 0x2710 1ee:	fb02 f203 	mul.w	r2, r2, r3 1f2:	f240 0300 	movw	r3, #0			1f2: R_ARM_THM_MOVW_ABS_NC	captura 1f6:	f2c0 0300 	movt	r3, #0			1f6: R_ARM_THM_MOVT_ABS	captura 1fa:	691b      	ldr	r3, [r3, #16] 1fc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8 200:	fb01 f303 	mul.w	r3, r1, r3 204:	18d1      	adds	r1, r2, r3 206:	f240 0300 	movw	r3, #0			206: R_ARM_THM_MOVW_ABS_NC	captura 20a:	f2c0 0300 	movt	r3, #0			20a: R_ARM_THM_MOVT_ABS	captura 20e:	689a      	ldr	r2, [r3, #8] 210:	4613      	mov	r3, r2 212:	ea4f 0383 	mov.w	r3, r3, lsl #2 216:	189b      	adds	r3, r3, r2 218:	ea4f 0343 	mov.w	r3, r3, lsl #1 21c:	461a      	mov	r2, r3 21e:	f240 0300 	movw	r3, #0			21e: R_ARM_THM_MOVW_ABS_NC	captura 222:	f2c0 0300 	movt	r3, #0			222: R_ARM_THM_MOVT_ABS	captura 226:	68db      	ldr	r3, [r3, #12] 228:	f04f 0064 	mov.w	r0, #100	; 0x64 22c:	fb00 f303 	mul.w	r3, r0, r3 230:	18d3      	adds	r3, r2, r3 232:	18ca      	adds	r2, r1, r3 234:	f240 0300 	movw	r3, #0			234: R_ARM_THM_MOVW_ABS_NC	captura 238:	f2c0 0300 	movt	r3, #0			238: R_ARM_THM_MOVT_ABS	captura 23c:	601a      	str	r2, [r3, #0]	captura[1]=adc_value-captura[0]; 23e:	f240 0300 	movw	r3, #0			23e: R_ARM_THM_MOVW_ABS_NC	adc_value 242:	f2c0 0300 	movt	r3, #0			242: R_ARM_THM_MOVT_ABS	adc_value 246:	681a      	ldr	r2, [r3, #0] 248:	f240 0300 	movw	r3, #0			248: R_ARM_THM_MOVW_ABS_NC	captura 24c:	f2c0 0300 	movt	r3, #0			24c: R_ARM_THM_MOVT_ABS	captura 250:	681b      	ldr	r3, [r3, #0] 252:	1ad2      	subs	r2, r2, r3 254:	f240 0300 	movw	r3, #0			254: R_ARM_THM_MOVW_ABS_NC	captura 258:	f2c0 0300 	movt	r3, #0			258: R_ARM_THM_MOVT_ABS	captura 25c:	605a      	str	r2, [r3, #4]	unsigned char i=5; 25e:	f04f 0305 	mov.w	r3, #5 262:	71fb      	strb	r3, [r7, #7]	do {		vUART_echo(captura[i]+48); 264:	79fa      	ldrb	r2, [r7, #7] 266:	f240 0300 	movw	r3, #0			266: R_ARM_THM_MOVW_ABS_NC	captura 26a:	f2c0 0300 	movt	r3, #0			26a: R_ARM_THM_MOVT_ABS	captura 26e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2] 272:	b2db      	uxtb	r3, r3 274:	f103 0330 	add.w	r3, r3, #48	; 0x30 278:	b2db      	uxtb	r3, r3 27a:	4618      	mov	r0, r3 27c:	f7ff fffe 	bl	0 <ADC1_IRQHandler>			27c: R_ARM_THM_CALL	vUART_echo		i--; 280:	79fb      	ldrb	r3, [r7, #7] 282:	f103 33ff 	add.w	r3, r3, #4294967295 286:	71fb      	strb	r3, [r7, #7]	}	while (i!=0); 288:	79fb      	ldrb	r3, [r7, #7] 28a:	2b00      	cmp	r3, #0 28c:	d1ea      	bne.n	264 <ADC1_IRQHandler+0x264>	vUART_echo('\r'); 28e:	f04f 000d 	mov.w	r0, #13 292:	f7ff fffe 	bl	0 <ADC1_IRQHandler>			292: R_ARM_THM_CALL	vUART_echo	vUART_echo('\n'); 296:	f04f 000a 	mov.w	r0, #10 29a:	f7ff fffe 	bl	0 <ADC1_IRQHandler>			29a: R_ARM_THM_CALL	vUART_echo} 29e:	f107 0708 	add.w	r7, r7, #8 2a2:	46bd      	mov	sp, r7 2a4:	bd80      	pop	{r7, pc} 2a6:	bf00      	nop